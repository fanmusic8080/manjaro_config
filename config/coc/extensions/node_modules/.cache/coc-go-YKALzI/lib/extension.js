"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const tools_1 = require("./utils/tools");
const commands_1 = require("./commands");
const modify_tags_1 = require("./utils/modify-tags");
const config_1 = require("./utils/config");
const editor_1 = require("./editor");
const binaries_1 = require("./binaries");
const tests_1 = require("./utils/tests");
const playground_1 = require("./utils/playground");
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        config_1.setStoragePath(context.storagePath);
        const config = coc_nvim_1.workspace.getConfiguration().get('go', {});
        if (config.enable === false) {
            return;
        }
        registerGopls(context, config);
        registerTest(context);
        registerTags(context);
        registerPlaygroud(context);
        context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.version", () => commands_1.version()));
    });
}
exports.activate = activate;
function registerGopls(context, config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const getGoplsPath = () => {
            if (config.commandPath) {
                coc_nvim_1.workspace.showMessage("Go: Configuration 'go.commandPath' is deprected, use 'go.goplsPath' instead!", "warning");
                return config.commandPath;
            }
            return config.goplsPath;
        };
        const command = getGoplsPath() || (yield tools_1.goBinPath(binaries_1.GOPLS));
        if (!(yield tools_1.commandExists(command))) {
            if (!(yield tools_1.installGoBin(binaries_1.GOPLS))) {
                return;
            }
        }
        const serverOptions = { command };
        const clientOptions = {
            documentSelector: ['go']
        };
        const client = new coc_nvim_1.LanguageClient('go', 'gopls', serverOptions, clientOptions);
        context.subscriptions.push(coc_nvim_1.services.registLanguageClient(client), coc_nvim_1.commands.registerCommand("go.install.gopls", () => commands_1.installGopls(client)));
    });
}
function registerTest(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!(yield tools_1.installGoBin(binaries_1.GOTESTS))) {
            return;
        }
        context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.gotests", () => commands_1.installGotests()), coc_nvim_1.commands.registerCommand("go.test.generate.file", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return tests_1.generateTestsAll(yield editor_1.activeTextDocument()); })), coc_nvim_1.commands.registerCommand("go.test.generate.exported", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return tests_1.generateTestsExported(yield editor_1.activeTextDocument()); })), coc_nvim_1.commands.registerCommand("go.test.toggle", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return tests_1.toogleTests(yield editor_1.activeTextDocument()); })));
    });
}
function registerTags(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!(yield tools_1.installGoBin(binaries_1.GOMODIFYTAGS))) {
            return;
        }
        context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.gomodifytags", () => commands_1.installGomodifytags()), coc_nvim_1.commands.registerCommand("go.tags.add", (...tags) => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.addTags(yield editor_1.activeTextDocument(), { tags }); })), coc_nvim_1.commands.registerCommand("go.tags.add.line", (...tags) => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.addTags(yield editor_1.activeTextDocument(), { tags, selection: "line" }); })), coc_nvim_1.commands.registerCommand("go.tags.add.prompt", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.addTags(yield editor_1.activeTextDocument(), { prompt: true }); })), coc_nvim_1.commands.registerCommand("go.tags.remove", (...tags) => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.removeTags(yield editor_1.activeTextDocument(), { tags }); })), coc_nvim_1.commands.registerCommand("go.tags.remove.line", (...tags) => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.removeTags(yield editor_1.activeTextDocument(), { tags, selection: "line" }); })), coc_nvim_1.commands.registerCommand("go.tags.remove.prompt", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.removeTags(yield editor_1.activeTextDocument(), { prompt: true }); })), coc_nvim_1.commands.registerCommand("go.tags.clear", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.clearTags(yield editor_1.activeTextDocument()); })), coc_nvim_1.commands.registerCommand("go.tags.clear.line", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return modify_tags_1.clearTags(yield editor_1.activeTextDocument(), { selection: "line" }); })));
    });
}
function registerPlaygroud(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.version", () => commands_1.version()), coc_nvim_1.commands.registerCommand("go.playground", () => tslib_1.__awaiter(this, void 0, void 0, function* () { return playground_1.openPlayground(yield editor_1.activeTextDocument()); })));
    });
}
//# sourceMappingURL=extension.js.map