"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cp = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const tools_1 = require("./tools");
const binaries_1 = require("../binaries");
////////////////////////////////////////////////////////////////////////////////
function addTags(document, params = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = coc_nvim_1.workspace.getConfiguration().get('go.tags', {});
        let tags = (params.tags && params.tags.length > 0)
            ? params.tags.join(',')
            : (config.tags || 'json');
        let options = (config.options || config.options === "")
            ? config.options
            : 'json=omitempty';
        const transform = (config.transform || "snakecase");
        if (params.prompt) {
            tags = yield coc_nvim_1.workspace.requestInput('Enter comma separated tag names', tags);
            if (!tags) {
                return;
            }
            options = yield coc_nvim_1.workspace.requestInput('Enter comma separated options', options);
        }
        yield runGomodifytags(document, [
            '-add-tags', tags.replace(/ +/g, ''),
            '-override',
            '-add-options', (options || ""),
            '-transform', transform,
            ...(yield offsetArgs(document, (params.selection || "struct")))
        ]);
    });
}
exports.addTags = addTags;
function removeTags(document, params = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = coc_nvim_1.workspace.getConfiguration().get('go.tags', {});
        let tags = (params.tags && params.tags.length > 0)
            ? params.tags.join(',')
            : (config.tags || 'json');
        if (params.prompt) {
            tags = yield coc_nvim_1.workspace.requestInput('Enter comma separated tag names', tags);
            if (!tags) {
                return;
            }
        }
        yield runGomodifytags(document, [
            '-remove-tags', (tags || "json"),
            '-clear-options',
            ...(yield offsetArgs(document, (params.selection || "struct")))
        ]);
    });
}
exports.removeTags = removeTags;
function clearTags(document, params = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield runGomodifytags(document, [
            '-clear-tags',
            '-clear-options',
            ...(yield offsetArgs(document, (params.selection || "struct")))
        ]);
    });
}
exports.clearTags = clearTags;
////////////////////////////////////////////////////////////////////////////////
function runGomodifytags(document, args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const fileName = document.uri.replace(/^file:\/\//, '');
        args.push('-modified', '-file', fileName, '-format', 'json');
        const input = fileArchive(fileName, document.getText());
        const edit = yield execGomodifytags(args, input);
        yield coc_nvim_1.workspace.applyEdit({ changes: { [document.uri]: [edit] } });
    });
}
function execGomodifytags(args, input) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const gomodifytags = yield tools_1.goBinPath(binaries_1.GOMODIFYTAGS);
        return new Promise((resolve, reject) => {
            const p = cp.execFile(gomodifytags, args, { env: {} }, (err, stdout, stderr) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (err) {
                    coc_nvim_1.workspace.showMessage(`Cannot modify tags: ${stderr}`);
                    return reject();
                }
                const mods = JSON.parse(stdout);
                resolve({
                    range: {
                        start: { line: mods.start - 1, character: 0 },
                        end: { line: mods.end, character: 0 }
                    },
                    newText: mods.lines.join("\n") + "\n"
                });
            }));
            if (p.pid) {
                p.stdin.end(input);
            }
        });
    });
}
function fileArchive(fileName, fileContents) {
    return fileName + '\n' + Buffer.byteLength(fileContents, 'utf8') + '\n' + fileContents;
}
// https://github.com/microsoft/vscode-go/blob/master/src/util.ts#L84
function byteOffsetAt(document, position) {
    const offset = document.offsetAt(position);
    const text = document.getText();
    return Buffer.byteLength(text.substr(0, offset)).toString();
}
function offsetArgs(document, seletion) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cursor = yield coc_nvim_1.workspace.getCursorPosition();
        switch (seletion) {
            case "struct":
                return ['-offset', byteOffsetAt(document, cursor)];
            case "line":
                return ['-line', String(cursor.line + 1)];
        }
        return [];
    });
}
//# sourceMappingURL=modify-tags.js.map