"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path_1 = require("path");
var child_process_1 = tslib_1.__importDefault(require("child_process"));
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var waitMap_1 = require("rxjs-operators/lib/waitMap");
var vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
var diagnostic_1 = require("../handles/diagnostic");
var workspaces_1 = require("./workspaces");
var util_1 = require("../common/util");
var logger_1 = tslib_1.__importDefault(require("../common/logger"));
var config_1 = tslib_1.__importDefault(require("./config"));
var log = logger_1.default('parser');
var parserHandles = {};
var indexes = {};
var origin$ = new rxjs_1.Subject();
var scanProcess;
var isScanRuntimepath = false;
function startIndex() {
    if (scanProcess) {
        return;
    }
    scanProcess = child_process_1.default.fork(path_1.join(__dirname, 'scan.js'), ['--node-ipc']);
    scanProcess.on('message', function (mess) {
        var data = mess.data, log = mess.log;
        if (data) {
            if (!workspaces_1.workspace.isExistsBuffer(data.uri)) {
                workspaces_1.workspace.updateBuffer(data.uri, data.node);
            }
        }
        if (log) {
            log.info("child_log: " + mess.log);
        }
    });
    scanProcess.on('error', function (err) {
        log.error("" + (err.stack || err.message || err));
    });
    scanProcess.send({
        config: {
            gap: config_1.default.indexes.gap,
            count: config_1.default.indexes.count
        }
    });
}
function next(textDoc) {
    if (!parserHandles[textDoc.uri]) {
        var uri_1 = textDoc.uri;
        parserHandles[uri_1] = origin$.pipe(operators_1.filter(function (textDoc) { return uri_1 === textDoc.uri; }), operators_1.switchMap(function (textDoc) {
            return rxjs_1.timer(100).pipe(operators_1.map(function () { return textDoc; }));
        }), waitMap_1.waitMap(function (textDoc) {
            return rxjs_1.from(util_1.handleParse(textDoc));
        }, true)).subscribe(function (res) {
            if (config_1.default.diagnostic.enable) {
                // handle diagnostic
                diagnostic_1.handleDiagnostic(textDoc, res[1]);
            }
            // handle node
            workspaces_1.workspace.updateBuffer(uri_1, res[0]);
            // scan project
            if (!indexes[uri_1]) {
                indexes[uri_1] = true;
                scanProcess.send({
                    uri: uri_1
                });
                if (!isScanRuntimepath) {
                    isScanRuntimepath = true;
                    scan([config_1.default.vimruntime].concat(config_1.default.runtimepath));
                }
            }
        }, function (err) {
            log.error("" + (err.stack || err.message || err));
        });
    }
    if (!scanProcess) {
        startIndex();
    }
    origin$.next(textDoc);
}
exports.next = next;
function unsubscribe(textDoc) {
    if (parserHandles[textDoc.uri] !== undefined) {
        parserHandles[textDoc.uri].unsubscribe();
    }
    parserHandles[textDoc.uri] = undefined;
}
exports.unsubscribe = unsubscribe;
// scan dirtory
function scan(paths) {
    if (!scanProcess) {
        startIndex();
    }
    if (config_1.default.indexes.runtimepath) {
        var list = [].concat(paths);
        for (var idx = 0; idx < list.length; idx++) {
            var p = list[idx];
            if (!p) {
                continue;
            }
            p = p.trim();
            if (!p || p === '/') {
                continue;
            }
            scanProcess.send({
                uri: vscode_uri_1.default.file(path_1.join(p, 'f')).toString()
            });
        }
    }
}
exports.scan = scan;
//# sourceMappingURL=parser.js.map